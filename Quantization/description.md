# Квантование сигнала: разрядность и ошибки
Если дискретизация — это деление сигнала по времени (ось $X$), то квантование — это деление по амплитуде (ось $Y$).

Когда мы превращаем бесконечно плавную волну в набор чисел, мы вынуждены «округлять» её значение до ближайшего разрешенного уровня. Именно здесь рождается шум, который нельзя убрать простым фильтром, — шум квантования.

## 1. Разрядность (Bit Depth)Количество уровней, на которые мы делим вертикальную ось, зависит от количества бит в твоем АЦП (аналого-цифровом преобразователе).
- 8 бит: $2^8 = 256$ уровней. (Звучит как старая рация или 8-битная приставка).
- 16 бит: $2^{16} = 65,536$ уровней. (Стандарт Audio CD).
- 24 бита: $2^{24} \approx 16.7$ млн уровней. (Студийное качество).

Чем больше бит, тем точнее «ступеньки» повторяют форму волны и тем меньше уровень шума.

## 2. Ошибка квантования
Разница между реальным значением сигнала и его округленной цифровой копией называется ошибкой квантования. В идеальном случае этот шум распределен равномерно.Существует «золотое правило» для инженеров (SQNR — Signal-to-Quantization-Noise Ratio):

$$
SQNR \approx 6.02 \cdot N + 1.76 \text{ dB}
$$

Где $N$ — количество бит. Каждый лишний бит дает нам примерно 6 дБ динамического диапазона.3. Практика на Python: «Ломаем» разрядностьДавай возьмем чистый синус и посмотрим, что с ним будет, если мы решим сэкономить и превратим его в 3-битный сигнал.

## Python
```Python
import numpy as np
import matplotlib.pyplot as plt 

# Генерируем чистый сигнал
fs = 1000
t = np.linspace(0, 0.1, fs)
signal = np.sin(2 * np.pi * 50 * t)

def quantize(data, bits):
    levels = 2**bits
    # Масштабируем сигнал в диапазон от 0 до levels-1
    quantized = np.round((data + 1) * (levels - 1) / 2)
    # Возвращаем обратно в диапазон [-1, 1] для сравнения
    return (quantized / (levels - 1) * 2) - 1

# Квантуем (например, до 3 бит — всего 8 уровней)
bits = 3
signal_q = quantize(signal, bits)
error = signal - signal_q

plt.figure(figsize=(12, 6))

plt.subplot(2, 1, 1)
plt.plot(t, signal, 'g', label='Оригинал', alpha=0.5)
plt.step(t, signal_q, 'r', label=f'Квантование ({bits} бит)')
plt.title(f"Эффект квантования: {2**bits} уровней")
plt.legend()

plt.subplot(2, 1, 2)
plt.plot(t, error, 'orange', label='Ошибка (Шум)')
plt.title("Ошибка квантования (разница между оригиналом и цифрой)")
plt.legend()

plt.tight_layout()
plt.show()
```
Почему это важно для радиосвязи?

В радио ты часто сталкиваешься с ситуацией, когда рядом с очень слабым сигналом (далекая станция) находится очень мощный (соседний передатчик).
- Если разрядности АЦП не хватит, слабый сигнал просто «утонет» в шуме квантования.
- Если мощный сигнал превысит максимальный уровень (0 dBFS), возникнет клиппинг (жесткое ограничение), который породит кучу гармоник и «забьет» весь эфир.