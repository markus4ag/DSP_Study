# Математика свертки (Convolution mathematics)

## 1. Общие положения

**Математика свертки** — это «двигатель» всей цифровой фильтрации. Если БПФ переносит нас в мир частот, то свертка — это то, что происходит с сигналом во **временной области**, когда он проходит через фильтр.

### Что такое свертка физически?

Представь, что у тебя есть входной сигнал $x[n]$ (поток чисел с АЦП) и импульсная характеристика фильтра $h[n]$ (набор коэффициентов, который мы получили, применив окно к функции Sinc).

**Свертка** — это способ вычислить выходной сигнал $y[n]$ путем «пропускания» сигнала через эти коэффициенты.

### Математическая формула

Для дискретных сигналов формула свертки выглядит так:

$$
y[n] = (x * h)[n] = \sum_{k=-\infty}^{\infty} x[k] \cdot h[n - k]
$$

Пусть тебя не пугает бесконечность в сумме. В реальности у цифрового фильтра (FIR) количество коэффициентов $h$ конечно (например, 31 или 101), поэтому сумма берется только по ним.

### Алгоритм «Flip, Slide, Multiply, Sum»

Чтобы понять, как это работает на пальцах, представь процесс в четыре шага:

1. **Flip (Отражение):** Мы берем коэффициенты фильтра $h$ и разворачиваем их задом наперед.
2. **Slide (Сдвиг):** Мы «прикладываем» этот развернутый фильтр к началу нашего сигнала.
3. **Multiply (Умножение):** Перемножаем каждое число фильтра на соответствующее число сигнала, над которым он сейчас «висит».
4. **Sum (Сложение):** Складываем все результаты умножения. Это и есть одно число на выходе фильтра.

Затем мы сдвигаем фильтр на один отсчет вперед и повторяем шаги 3 и 4. Так рождается новый отфильтрованный сигнал.

### Почему это важно для радио?

Каждый коэффициент в $h[n]$ — это, по сути, «память» фильтра. Чем больше коэффициентов (длиннее фильтр), тем:

- Точнее мы можем «вырезать» частоту.
- Круче будут скаты фильтра.
- **Но:** тем больше задержка (latency) и выше нагрузка на процессор.

**Интересный факт:** Свертка во временной области — это обычное умножение в частотной области. Именно поэтому мы можем фильтровать сигнал либо «двигая» фильтр вдоль него, либо перейдя в спектр через БПФ, умножив его на график фильтра и вернувшись обратно.

### Как это выглядит в Python (NumPy)

Вместо того чтобы писать циклы `for`, в NumPy используется готовая оптимизированная функция:

#### Python
```Python
import numpy as np

# x - наш сигнал, h - коэффициенты фильтра
y = np.convolve(x, h, mode='same')
```
Параметр `mode='same'` нужен, чтобы выходной сигнал был такой же длины, как входной.

## 2. Пример с «ручным» расчетом свертки

Чтобы «прочувствовать» свертку, давай возьмем совсем простые числа. Это база, на которой строятся все фильтры в твоем SDR-приемнике или аудио-редакторе.

Представь, что у нас есть:

- **Входной сигнал** $x[n]$: `[1, 2, 3]` (три отсчета амплитуды).
- **Импульсная характеристика (фильтр)** $h[n]$: `[1, 0.5]` (коэффициенты фильтра).

Наша задача — найти выходной сигнал $y[n]$.

### Шаг 1: Разворачиваем фильтр (Flip)

Это самый важный момент в математике свертки. Мы берем $h[n]$ и записываем его задом наперед.

- Было: `[1, 0.5]`
- Стало: `[0.5, 1]`

### Шаг 2: Скользим и считаем (Slide, Multiply, Sum)

Теперь мы «протаскиваем» наш развернутый фильтр вдоль сигнала. В тех местах, где чисел нет, считаем их равными **0**.

#### Точка 1 ($n=0$):

Фильтр только «коснулся» сигнала.

```Plaintext
Сигнал:       1   2   3
Фильтр: [0.5, 1]
```

Умножаем то, что совпало: $1 \cdot 1 = 1$.$y[0] = 1$

#### Точка 2 ($n=1$):

Сдвигаем фильтр на один шаг вправо.

```Plaintext
Сигнал:    1    2    3
Фильтр:  [0.5,  1]
```

Теперь совпадают две пары чисел: $(2 \cdot 1) + (1 \cdot 0.5) = 2 + 0.5 = 2.5$.$y[1] = 2.5$

#### Точка 3 ($n=2$):

Сдвигаем еще дальше.

```Plaintext
Сигнал:    1    2    3
Фильтр:       [0.5,  1]
```

Снова две пары: $(3 \cdot 1) + (2 \cdot 0.5) = 3 + 1 = 4$.$y[2] = 4$

#### Точка 4 ($n=3$):

Фильтр почти вышел за пределы сигнала.

```Plaintext
Сигнал:    1    2    3
Фильтр:            [0.5,  1]
```

Совпадает только последняя пара: $(3 \cdot 0.5) = 1.5$.$y[3] = 1.5$

### Результат

На выходе мы получили последовательность: `[1, 2.5, 4, 1.5]`.

### Что произошло с сигналом?

Заметь, что исходный сигнал был `[1, 2, 3]`, а выходной стал более «плавным» и растянутым. Коэффициент `0.5` добавил к текущему значению половину предыдущего. Поздравляю, ты только что вручную реализовал **простейший фильтр нижних частот (Low-Pass Filter)!**

### Почему в формуле стоит «минус»?

Помнишь ту страшную формулу: $\sum x[k] \cdot h[n - k]$?

Этот самый **минус** в $h[n - k]$ и отвечает за то, что мы **разворачиваем** фильтр. Математически это нужно, чтобы соблюдался закон причинности (результат в настоящем зависит от прошлого, а не от будущего).